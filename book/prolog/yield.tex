\secrel{Генераторные функции и yield}\label{yield}

Ключевое слово \file{yield}\ в \py\ превращает любую функцию, в которой оно
используется, в функцию-\term{генератор}. Вызов генератора вместо
выполнения функции возвращает объект-\term{итератор}. Если его использовать в
качестве параметра цикла \file{for}, или явно вызывать встроенй метод
\verb|__next__()|, то вы сможете использовать \term{ленивые вычисления}\ в
обычной императивной программе на \py.

\begin{quotation}\noindent
\term{Ленивые вычисления} (англ. lazy evaluation, также отложенные вычисления)\
--- применяемая в некоторых (функциональных) языках программирования стратегия
вычисления, согласно которой вычисления следует откладывать до тех пор, пока не
понадобится их результат.
\end{quotation}

В рамках \py\ полная реализация ленивых вычислений недоступна \ref{lazy}, тем не
менее использование генераторов позволяет вычислять функции в бесконечном цикле,
возвращая промежуточные результаты. Также на генераторных функциях построен
механизм \term{логического вывода в возвратами}, используемый в языке \prolog,
который мы рассмотрим далее.

\medskip
\lst{prolog/00.py}{language=Python}

Генератор \file{person()}\ соответствует 0-арному \term{отношению}
\file{person()}, которое определяет свойство быть человеком (person) для
некоторых внешних объектов, которые явно не указаны в качестве параметров
отношения.

\begin{quotation}\noindent
\term{отношение}\ --- свойство некоторого объекта, или связность нескольких
объектов между собой.
\end{quotation}

\begin{quotation}\noindent
\term{арность}\ --- число объектов: параметров отношения
\end{quotation}

\begin{quotation}\noindent
\term{предик\'{а}т} (n-местный, или \term{n-арный})\ --- это логическая функция
с множеством значений \{0,1\} или \{false,true\} (\{ложь, истина\}),
определённая на множестве $M=M_1 \times M_2 \times \ldots \times M_n$. Таким
образом, каждый набор элементов множества $M$ характеризуется либо как
``истинный'', либо как ``ложный''.
\end{quotation}
Предикат можно связать с математическим \term{отношением}: если кортеж\\
$(m_1,m_2,\dots ,m_n)$ принадлежит отношению, то предикат будет возвращать на
нем \file{true}. В частности, одноместный предикат определяет отношение
принадлежности некоторому множеству.

\begin{description}[nosep]
\item[унарное отношение] \file{relation(object)}\\
определяет некоторое свойство объекта, задает \term{множество} объектов,
обладающих этим свойством, и соответствует одноименной функцию-предикату
способную проверить обладает ли \file{object} заданным свойством \file{relation}
\item[бинарное отношение] \file{binar(obj1,obj2)}\\
связывает два объекта
\item[n-арное отношение] \file{Nary(obj1,\ldots)}\\
\verb|sum(A,B,product)| задает \term{тернарное} отношение суммы: \verb|product|
является суммой \verb|A| и \verb|B| (порядок параметров предиката важен, но не
предопределен)
\item[нуль-арное отношение] \file{time()}\\
обобщение, отношение заданное для внешних, явно не указанных, неименованных
объектов; например текущее время, или состояние системы. Такие объкты можно
задавать и логической переменной, но описание отношения принадлежности строк
файлу \verb|FileName()| получится значительно сложнее, многословнее, и скорее
всего с использованием рекурсии.
\end{description}

\bigskip
Генератор (отношение) может быть задан и для бесконечного множества значений,
например бесконечной последовательности, и как раз здесь срабатывает принцип
ленивых вычислений: каждое новое значение вычисляется по необходимости, в нужный
момент, при этом не требуется\note{потенциально бесконечная, или
непредсказуемая} резервация памяти для хранения данных.

\medskip
\lst{prolog/01.py}{language=Python}
\lst{prolog/02.py}{language=Python}
