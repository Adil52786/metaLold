\secrel{Раскрутка языка (bootstrap)}\label{circ}\secdown

В этой книге нам нужно показать всю мощь языка специально заточенного под
метапрограммирования. Лучшим способом для этого является его \term{bootstrap},
или \term{раскрутка}: написать \term{метациркулярную} реализацию языка
программирования\ --- \emph{на нем самом}.

\secrel{Метациркулярный интерпретатор}

\begin{quotation}
Метациркулярный интерпретатор является интерпретатором, написанным в (возможно,
более базовой) реализации того же языка. Обычно это делается для того, чтобы
экспериментировать с добавлением новых функций на язык или созданием другого
диалекта.
\end{quotation}

В целях демонстрации того, как работает язык программирования, в литературе
часто применяют этот метод: некоторые части интерпретатора описываются на том же
языке программирования. Это позволяет не только показать внутреннее устройство,
но и служит реальным примером применения.

Если в комплект поставки включить полную метациркулярную реализацию языка,
пользователь также может адаптировать язык под свои нужды, или написать свой
клон, но для этого должно выполняться одно очень важное, критическое условие\
--- \emph{документация должна поставляться} не как руководство
пользователя, а \emph{как учебник по написанию собственной версии языка}.

\bigskip
Понять метациркулярность \textit{компилятора} очень просто: у нас есть исходный
код компилятора для некоторого языка программирования, и исполняемый файл этого
компилятора, оба версии N. Исходный код модифицируется, подается на вход
\file{компилятора-N}, в результате получем исполняемый код
\file{компилятора-N+1}. Для тестирования новой версии мы еще раз подаем исходный
код N+1 на вход \file{компилятора-N+1}, и он собирает сам себя. Такой способ в
частности применяется при сборке GCC из GNU Compilers Collection.
Собственно говоря, это единственный способ написать самодостаточный компилятор
такого системного языка как \emc: стартовая версия компилируется другим
(коммерческим) компилятором (раньше писали на ассемблере), а затем
происходит \term{раскрутка компилятора}.

\clearpage
Для интерпретаторов динамических языков используется другой способ \cite{plai},
похожий на то как мы написали всю внутреннюю механику \metal\ на \py:
реализация нового языка-N+1 представляется в виде множества явно выделенных
структур данных, которые интерпретируются исполняющим кодом на языке-N.

\bigskip
Метапрограммирование, а точнее \term{кодогенерация}, предлагает еще одну
альтернативу: ядро интерпретатора, написанное на языке \py, выполняет
метапрограмму на языке \metal, который \emph{генерирует исходный код} реализации
интерпрератора на языке Java\note{и прочее барахло в файлах проекта для
Android}, которое в итоге будет работать как интерпретатор языка \F\ на
мобильном телефоне. Это самый обкуренный пример, специально переусложненный
для демонстрации, на самом деле бы пока ограничимся только цепочкой
\py$\rightarrow$\metal$\rightarrow$\py$\rightarrow$\metal$_{N+1}$.

\secrel{Метамодель языка \metal\ с генерацией кода}

\metal\ запускается с загрузкой инициализационного файла \file{metaL.ini}
\ref{ini}, который по умолчанию содержит полную модель системы и множество
других определений (для встроенного программирования, и для самораскрутки
системы). Запустив систему, вы получаете возможность делать \term{разработку
через клонирование}: при контрактной разработке передается система \metal,
дополненная функционалом, заказанным клиентом.

Такой подход особенно хорош если у вас множество заказчиков, которым вы
поставляете примерно одну и ту же систему, но с различными модификациями. Вы
можете наследовать значительные блоки исходного кода и дизайна\note{структуры
данных, реализация алгоритмов, компоненты, документацию \ref{doc},..},
прописывая для каждого клиента только те блоки, которые вы ему поставляете, а
кодогенерация сама будет отслеживать обновления и зависимости.

\clearpage
\lst{meta/header.ini}{language=Python}
Здесь вы сразу видите два варианта \term{строчных комментариев}: в стилях \py\ и
\F. Одновременно \file{metaL.ini} также является последним этапом
интеграционного тестирования, проверяющим работу всех фич языка.

\input{meta/ouro/boros}

\secup