\clearpage
\subsecly{Метапрограммирование}\label{meta}

\begin{quotation}\noindent
Метапрограммирование — вид программирования, связанный с созданием
\textit{программ, которые порождают другие программы} как результат своей работы
(в частности, на стадии компиляции их исходного кода), либо программ, которые
меняют себя во время выполнения (самомодифицирующийся код).
\end{quotation}

\begin{itemize}
  \item 
\url{https://www.youtube.com/watch?v=QKFrxEkVusg}
  \item 
\url{https://www.youtube.com/watch?v=bt6kU1kuHWA}
\end{itemize}

\noindent
Традиционно при написании программ стараются писать код максимально переносимым
между различными компиляторами. ОС и аппаратурой, для этого создают различные
фреймворки, HAL, стандартные библиотеки и т.п. В итоге вместо быстрых
эффективных программ получаются \textbf{Jаба}троны завернутые в десятки слоев
абстракций и выжирающих ОЗУ гигабайтами\note{Eclipse на запуске на пару минут
вырубает не самый тухлый i7}.
Метапрограммирование через генерацию кода способно решить обратную задачу:
получение исходного кода на \textit{embedded \emc}\ \note{\cpp, \java\ или любом
другом языке, в т.ч. на \py\ для самораскрутки системы}\ максимально
учитывающего все особенности используемой аппаратуры, окружения и конкретной
решаемой задачи. Общая идея\ ---
\begin{itemize}[nosep]
  \item 
\emph{шаблонизация}, 
  \item 
\emph{параметризация} и 
  \item 
\emph{наследование} \textbf{исходного кода}
\end{itemize}
написанного на языках программирования, которые в принипе не знают об ООП,
наследовании и шаблонах (ISO \emc, Makefile, МЭК 61131-3), или не способных их
полноценно реализовать\ \note{интерересно через сколько десятилетий наконец
додумаются встроить в компилятор \cpp\ интерпретатор (\lisp а?) для построения
кода в compile time, вместо сомнительных шаблонов?}. Вся абстрактная каша должна
оставаться на рабочей станции разработчика в высокоуровневом \py-коде,
результат\ --- низкоуровневый код на \emc/LLVM способный работать на сотнях байт
ОЗУ\note{типичное требование для прошивок аппаратуры, сделанных на дешевых
low-end микроконтроллерах, имеюших всего \emph{2+ Кило}байта ОЗУ}.

Идеальным результатом применения metapy будет код, не выполняющий ни одной
машинной инструкции, которая не является необходимой для инициализации
конкретной железки, или решения текущей задачи. Если код должен работать поверх
ОС, в идеале он должен использовать только нативный API и
\term{специфицированный} код
вместо сторонних библиотек и особенно мультиплатформенных фрейморков. В
реальности естественно приходится ограничиваться точечным применением, т.к. есть
legacy код, требования к читаемости выходного кода, обучение программистов
сложной методике, сложность реализации вывода (компиляция мета-моделей), и
невозможность переписать в виде метамоделей весь используемый набор сервисов и
библиотек.
