\subsecly{Серебряная пуля Брукса}

Сущностью программирования является, прежде всего, не написание инструкций на
конкретном языке программирования, а выработка подробной структуры
взаимодействующих сущностей проблемной области, а также проверка внутренней
непротиворечивости этой структуры.
Следовательно, ни одно средство разработки ПО не сможет существенно снизить
сложность разработки, так как даже если, например, изобрести компьютерный язык,
оперирующий понятиями на уровне проблемной области, программирование все равно
останется сложной задачей, поскольку придется точно определять взаимосвязи между
объектами реального мира, устанавливать исключения, предусматривать все
возможные переходы между состояниями и т.д.

Что делает язык высокого уровня? Они изолируют программу от большей части ее
нецелевой сложности. Абстрактная программа состоит из концептуальных
конструкций: операций, типов данных, последовательностей и коммуникации.
Конкретная машинная программа связана с битами, регистрами, условиями, ветвями,
каналами, дисками и тому подобным. В той степени, в которой язык высокого уровня
воплощает конструкции, которые нужны в абстрактной программе, и избегает всех
нижестоящих, он устраняет целый уровень сложности, который вообще никогда не был
присущ программе. Безусловно, уровень нашего мышления о структурах данных, типах
и операциях неуклонно растет в сторону прикладной области благодаря
возможностям абстракции, предоставляемым ООП, но с постоянно уменьшающейся
скоростью\ --- развитие языков и абстракий движется все ближе и ближе к
прикладной сложности пользователей. Более того, в какой-то момент разработка
языка высокого уровня и фреймворков создает бремя владения инструментом, которое
увеличивает, а не уменьшает интеллектуальную сложность пользователя.

Многие люди ожидают, что достижения в области искусственного интеллекта
обеспечат революционный прорыв, который даст увеличение производительности и
качества программного обеспечения на порядок. При этом не стоит путать
"численный ИИ" как он широко известен сейчас, т.е. нейроные сети и машинное
обучение, с \term{семантическим ИИ}, выполняющим логический вывод \emph{на
основе сетей взаимосвязанных понятий и отношений между объектами}. Наиболее
широко известная технология семантического ИИ\ --- \term{экспертные системы}.

\begin{quotation}\noindent
Экспертная система\ --- это программа, которая содержит обобщенный механизм
логического вывода и базу правил и отношений, принимает входные данные и
предположения, генерурет гипотезы, выводимые из базы правил, дает выводы и
рекомендации, и предлагает объяснение свои результатов для пользователя (путем
отслеживания цепочки логического вывода). Механизмы вывода часто могут иметь
дело с нечеткими или вероятностными данными и правилами, в дополнение к чисто
детерминированной логике.
\end{quotation}

Как эта технология может быть применена к задаче разработки программного
обеспечения?

Работа, необходимая для генерации базы знаний\ --- это работа, которую в любом
случае необходимо будет не просто выполнить единожды, но и постоянно
поддерживать базу знаний в актуальном состоянии. Многие трудности стоят на пути
скорейшей реализации полезных экспертных системных советников для разработчика
программ. Важной частью нашего воображаемого сценария является разработка
простых способов перехода от спецификации структуры программы к автоматической
или полуавтоматической генерации кода, созданию правил тестирования и
диагностики, скриптов развертывания и средств мониторинга. Еще более трудной и
важной проблемой является получение знаний в двух направлениях: поиск четких,
самоаналитичных экспертов, которые знают, почему они делают что-то, и разработка
эффективных методов извлечения того, что они знают, и выражение их знаний в базу
правил. Необходимым условием для построения экспертной системы является наличие
эксперта.

Самым мощным вкладом экспертных систем, безусловно, должно быть предоставление
на службу неопытному программисту опыта и накопленной мудрости лучших
программистов. Это немалый вклад. Разрыв между лучшей практикой разработки
программного обеспечения и средней практикой очень велик\ --- возможно, больше,
чем в любой другой инженерной дисциплине. Инструмент, который распространяет
передовой опыт, был бы важен.

В течение почти 50 лет люди ожидали и писали об «автоматическом
программировании» или создании программ на основе формулировки спецификаций
проблемы. Некоторые сегодня пишут, как будто они ожидают, что эта технология
обеспечит следующий прорыв. Короче говоря, автоматическое программирование
всегда было эвфемизмом для программирования на языке более высокого уровня, чем
было доступно в настоящее время программисту.

Техника создания \term{генераторов кода} очень мощная, и она обычно дает хорошие
преимущества для программ \term{синтаксического разбора} и реализаций протоколов
обмена данными. 

Графическое программирование. Любимый предмет для докторской диссертации в
области разработки программного обеспечения представляют собой графическое или
визуальное программирование\ --- применение компьютерной графики к разработке
программного обеспечения. Предполагаемый успех, обеспечиваемоый таким подходом,
постулируется по аналогии с САПР для микросхем СБИС, в которых компьютерная
графика играет плодотворную роль. Иногда теоретик оправдывает такой подход,
рассматривая блок-схемы как идеальную среду разработки программ и предоставляя
мощные средства для их построения. Тем не менее ничего, более-менее
убедительного, не говоря о чем-то большем, еще не появилось в результате таких
усилий.

Блок-схема является очень плохой абстракцией структуры программного обеспечения.
В жалкой, многостраничной, топорной форме, к которой сегодня сводится
блок-схема, она оказалась бесполезной в качестве средства разработки ПО\ ---
программисты рисуют блок-схемы после написания описываемых ими программ, а не
раньше.

Самая сложная часть построения программной системы\ --- это решить, что именно
строить. Никакая другая часть концептуальной работы не является такой сложной,
как разработка подробных технических требований, включая все интерфейсы для
людей, машин и других программных систем. Никакая другая часть работы не наносит
больший вред полученной системе, если она сделана неправильно. Никакую другую
часть дизайна не сложнее исправить если допущены ошибки.

Следовательно, наиболее важной функцией, которую разработчик программного
обеспечения выполняет для клиента, является итеративное извлечение и уточнение
требований к продукту. По правде говоря, клиент не знает, чего он хочет. Клиент
обычно не знает, на какие вопросы нужно ответить, и он почти никогда не
задумывался о проблеме до деталей, необходимых для спецификации. Даже простой
ответ\ --- «заставить новую программную систему работать как наша старая система
ручной обработки информации»\ --- слишком прост. Никто не хочет именно этого.
Более того, сложные программные системы\ --- это то, что действует, движется, и
изменяется в процессе работы. Динамику этого процесса трудно представить. Таким
образом, при планировании любой деятельности по разработке программного
обеспечения необходимо предусмотреть обширную итерацию между клиентом и
разработчиком как часть определения системы.

Более того, клиенту, даже работающему в паре с инженером-програм\-мистом,
действительно невозможно полностью, точно и правильно указать точные требования
к современному программному продукту, прежде чем пытаться практически
использовать несколько версий продукта. Поэтому одним из наиболее многообещающих
из текущих технологических усилий, который затрагивает суть проблемы
программного обеспечения, является \emph{разработка подходов и инструментов для
быстрого прототипирования систем}, поскольку прототипирование является частью
итеративной спецификации требования.

Прототип программной системы\ --- это система, которая имитирует важные
интерфейсы и выполняет основные функции предполагаемой системы, но при этом
необязательно ограничивается теми же аппаратными ограничениями по скорости,
размеру или стоимости. Прототипы, как правило, выполняют основные задачи
приложения, но не пытаются реализовывать полный функционал, поддерживать все
интерфейсы и форматы, или иметь документацию. Цель прототипа\ --- реализовать
заданную концептуальную структуру, чтобы клиент мог проверить ее на
согласованность и удобство использования.

Даже простые приложения никогда сначала и до конца не создаются по
свецификациям. Инкрементальное развитие\ --- программное обеспечение
выращивается, а не строится по чертежам. Концептуальные структуры, которыми мы
оперируем сегодня, слишком сложны, чтобы их можно было точно определить заранее,
и даже слишком сложны, чтобы их можно было безошибочно построить даже за один
цикл эволюции программы. Если мы обратим внимание на природу, и изучим сложность
в живых существах, мы найдем конструкции, сложность которых потрясает. Один
только мозг запутан выше возможности картографирования, мощен за пределами
имитации, богат разнообразием, самозащитой и самообновлением. Секрет в том, что
он вырос, а не построен по ТЗ.

Так должно быть и с нашими программными системами. То есть систему сначала нужно
заставить работать, даже если она не делает ничего полезного, кроме вызова
правильного набора подпрограмм-заглушек. \textit{Подход неудобен для
проектирования сверху вниз, поскольку создание множества таких заглушек отнимает
силы и запутывает код, нужно постоянно помнить детали, отличать заглушку от
рабочего кода разной степени готовности, и какие множества входных параметров
допустимы. Намного проще строить систему снизу вверх, имея работающую систему
хотя бы частично. Нельзя реализовывать при этом функции ``на будущее'', если вы
не можете их немедленно протестировать, и использовать для дальнейшего роста}.
