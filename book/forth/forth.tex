\secrel{\F\ как примитивный язык CLI}\label{forth}\secdown

\begin{quotation}\noindent
\term{CLI}\ --- Command Line Interface, \term{интерфейс командной строки}\ ---
разновидность текстового интерфейса между человеком и компьютером, в котором
инструкции компьютеру даются путём ввода с клавиатуры текстовых строк (команд).
Также известен под названием \term{консоль}.
\end{quotation}

\noindent
CLI всегда активно использовался профессиональными программистами и операторами,
и все еще остается основным интерфейсом на встраиваемых системах, и на рабочих
станциях UNIX/Linux.

\begin{quotation}\noindent
\term{REPL} (от англ. Eead-Eval-Print Loop\ --- цикл чтение\ -- вычисление\ --
вывод)\ --- форма организации простой интерактивной среды программирования в
рамках средств интерфейса командной строки. Чаще всего этой аббревиатурой
характеризуется интерактивная среда языка программирования \lisp, однако такая
форма характерна и для минимальных интерактивнйых сред многих других языков,
реализованных в виде интерпретатора.
\end{quotation}

\clearpage
\noindent
В такой среде пользователь может вводить выражения, которые среда тут же будет
вычислять, а результат вычисления отображать пользователю. Названия элементов
цикла связаны с примитивами \lisp а:

\begin{description}
\item[read] читает одно выражение и преобразует его в соответствующую структуру
данных в памяти (строку или \term{синтаксическое дерево});
\item[eval] принимает одну такую структуру данных и вычисляет соответствующее ей
выражение; \textit{большинство интерпретаторов на этом этапе запускают
внутренний компилятор}, который гененерирует \term{байт-код} \ref{bc}
\term{виртуальной машины} \ref{vm}, или реальный машинный код
\item[print] принимает результат вычисления выражения и печатает его
пользователю.
\end{description}

\noindent
Чтобы реализовать REPL-среду для некоторого языка, достаточно реализовать три
функции: чтения, вычисления и вывода, и объединить их в бесконечный цикл.
REPL-среда очень удобна при изучении нового языка и экспериментов, так как
предоставляет пользователю быструю обратную связь.

% \clearpage
\begin{quotation}\noindent
\emph{REPL/CLI необходим для интерактивного командного управления} различным
оборудованием через последовательный порт, USB/Serial или в сетевой сессии
telnet/ssh. В большинстве случаев такая \emph{языковая оболочка крайне полезна и
для реализации протоколов обмена данными в режиме машина/машина (m2m)}\ ---
языковые вредства интерпретатора позволяют \emph{неограниченно расширять
протокол обмена и логику команд}, который при этом остается человеко-читаемым,
что очень удобно для отладки и логирования.
\end{quotation}

\clearpage
Язык \F\ \cite{starting} является самым примитивным языком программирования, про
который можно сказать, что он \textit{не имеет синтаксиса}: его \term{парсер}
крайне примитивен, и реализуется всего в несколько машинных команд на любой
платформе.

\F\ изначально был создан
\href{https://ru.wikipedia.org/wiki/%D0%9C%D1%83%D1%80,\_%D0%A7%D0%B0%D1%80%D0%BB%D1%8C%D0%B7\_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82)}{Чальзом
Муром}\ как раз для задач управления оборудованием Национальной
радиоастрономической обсерватории (NRAO). И он \textit{так и остался непобедим в
этой роли} до настоящего времени, \textit{для применения в качестве CLI} на
самых маломощных компьютерах на базе \term{микроконтролер}ов.

У этого языка в оригинальном варианте крайне неприятный постфиксный синтаксис и
никоуровневая модель виртуальной машины, делающие бессмысленными попытки
его использования в качестве универсального языка программирования. С другой
стороны, этот же \textit{синтаксис оказывается удобным для однострочных
команд}: не требуется елозить по тексту и править множество вложенных скобок.

\clearpage
Как вы увидите дальше, \emph{главное достоинство \F а\ --- простота реализации}.
Второе достоинство, важное для встраиваемых систем: \emph{классическая
\F-система для своей работы требует \textbf{всего несколько Кб (!)} ОЗУ}, но мы
пока не будем углубляться на такой низкий уровень программирования.

\bigskip
Традиционная \F-система состоит из двух частей: исполняющая среда,
\term{виртуальная \F-машина}, или FVM\note{по аналогии с JVM}, и
\term{транслятор}. Транслятор занимается обработкой исходного текста команд и
программ, FVM выполняет готовый программный код.

Эти две части могут работать и независимо. Для встраиваемых систем и
коммерческих разработок можно использовать только FVM для выполнения
скомпилированной ранее программы. Если вы не хотите использовать \F\ для чтения
конфигурационных файлов или реализации командного протокола, то транслятор не
нужен.

Но нам эти детали не важны, так как мы планируем не затаскивать реализацию FVM
на целевую систему (микроконтроллер), а использовать более мощные методики,
позволяющие стыковать магические технологии с mainstream средствами и
компиляторами, применяемыми для коммерческой разработки.

Также нам не нужна полнофункциональная \F-система и на рабочей станции, мы
возьмем от нее только общий принцип минимального интерпретатора, и значительно
отойдем от классического Форта. Чтобы не путаться, для этого огрызка стоит взять
другое имя, я назвал его \pyf.

\secrel{Стек данных}

Итак, что у нас остается? Прежде всего это \emph{стек} \ref{stack}: он
\textit{удобен для манипуляций, запускаемых короткими командами}, и
\emph{освобождает нас от указаний где сохранять промежуточные данные}.

\medskip
\lst{forth/stack.py}{language=Python}

\secrel{Словарь}

\lst{forth/words.py}{language=Python}

\secrel{Парсер на базе библиотеки PLY}\label{ply}

Библиотека PLY позволяет писать \term{парсеры} для достаточно сложных языков.
Несмотря на то что диалекты \F/\pyf\ требуют только реализацию \term{лексера},
есть смысл немного сэкономить усилия, и не заморачиваться с написанием
традиционного посимвольного разбора ``до пробела''. Если вам для какой-то задачи
потребуется применение \term{инфиксного синтаксиса}, типа разбора арифметических
выражений, вы сможете без особых усилий добавить для них \term{синтаксический
анализатор}.

Еще одно достоинство использования PLY: с ее мопощью мы можем автоматически
определять тип для каждой лексемы, в частности разпознавать примитивные типы
\ref{prim}\ и вызывать соответствующие конструкторы. В \ref{typeval}\ есть
особая сноска по этому поводу: для совместимости с PLY были специально выбраны
имена переменных типа и значения: \verb|type| и \verb|value|.

\secrel{Интерпретатор}

\lst{forth/word.py}{language=Python}
\lst{forth/find.py}{language=Python}
\lst{forth/execute.py}{language=Python}
\lst{forth/repl.py}{language=Python}

\secup
