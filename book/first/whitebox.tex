\secrel{Эффект белого ящика}\label{whitebox}

У метапрограммирования есть один неочевидный, но критический недостаток, который
скорее всего и делает эту методику разработки ПО\note{и по-настоящему
динамические гибкие языки программирования, такие как \F, \st, \self, \lisp,
которые в большей или меньшей степени позволяют \textit{адаптировать язык} под
нужны конкретного программиста
%, добавляя новые синтаксические конструкции, и иногда
%позволяя вмешиваться в работу внутренних механизмов
} настолько мало применяемой: \term{эффект белого ящика}.

Когда вы пользуетесь каким-нибудь широкого распространенным языком
программирования, \emph{вы изолированы от деталей реализации не только языка, но
и внутренностей большинства библиотек и фрейворков, которыми вы пользуетесь}. У
вас есть гугл, руководство по компилятору, документация на библиотеки и
литература, \textit{которые описывают интерфейсы}. Вам в очень редких случаях
приходится лезть в исходники распространенных библиотек, и практически никогда в
исходники компилятора.

\bigskip
Священная корова computer science\ --- \term{сложность разработки ПО}\ ---
скрыта за множеством слоев от прикладного программиста. Тяжелые прикладные
библиотеки, фрейворки, и особенно интерпретаторы/компиляторы выступают в роли
классического черного ящика, с очень хорошо описанными интерфейсами.

\bigskip
Как только вы начинаете использовать метапрограммирование, а особенно языки
программирования домашней варки, все пропало! Вы досконально знаете каждый
закоулок ваших инструментов, и голова взрывается от обилия деталей. Этот эффект
известен для обычных больших проектов, но он не так заметен, так как набор
сложности происходит постепенно, и не так болезненен: ``это то же большой
проект, вполне ожидаемо, что он будет сложным''. При интенсивном использовании
метапрограммирования набор (кажущейся?) сложности происходит очень быстро, даже
на игрушечных проектах.

\bigskip
С другой стороны, как только ваш инструментарий
