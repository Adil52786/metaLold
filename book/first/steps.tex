\secrel{Первые шаги}\secdown

Перед вами книга, посвященная созданию очень примитивных языков программирования
на \py. Здесь вы не найдете ленивых лямбд и жутких монад, живущих в лесу
Хомского, и прочей бурбулятристики про обощенный вывод типов.
И все же мне хочется пошагово показать создание собственной реализации языка
программирования, более близкого по ощущениям к Self, Smalltalk и \lisp.
В реализациях этих языков вы можете \emph{автоматически строить части программ
во время исполнения}, вмешиваться в процесс работы ядра языка, и добавлять в
язык различные возможности нужные конкретно вам, например смешивать
фнукциональное, императивное и логическое программирование.

\begin{quotation}\noindent
Метапрограммирование — вид программирования, связанный с созданием
\textit{программ, которые порождают другие программы} как результат своей работы
(в частности, на стадии компиляции их исходного кода), либо программ, которые
меняют себя во время выполнения (самомодифицирующийся код).
\end{quotation}

\begin{itemize}
  \item 
\url{https://www.youtube.com/watch?v=QKFrxEkVusg}
  \item 
\url{https://www.youtube.com/watch?v=bt6kU1kuHWA}
\end{itemize}

Такие богатейшие возможности \term{метапрограммирования} возможны благодара
тому, что эти языки \term{гомоиконичны}: их реализацации работают как
\emph{живая интерактивная система} использующая структуры данных как
представление программы и исполняемый код.

\begin{quotation}\noindent
\term{Гомоикон\`{и}чность} (гомоиконность, англ. homoiconicity, homoiconic)\\
свойство некоторых языков программирования, в которых \emph{представление
программ является одновременно структурами данных} определенных в типах самого
языка, \emph{доступных для просмотра и модификации}. Говоря иначе,
гомоиконичность\ --- это когда исходный \textit{код программы} пишется
\textit{как базовая структура данных}, и язык программирования знает, как
получить к ней доступ на чтение и запись (в том числе в рантайме при работе
программ у конечного пользователя).
\end{quotation}

\clearpage
Реализация языков такого типа \ref{implement}\ строится на \emph{интерпретаторе
структур данных}. По какой-то странной причине почему-то принято
противопоставлять \term{интерпретатор} и \term{компилятор}. Могу вас
обрадовать: \textit{все современные интерпретаторные реализации языков
программирования в обязательном порядке включают компилятор}\note{как минимум в
байт-код}.

На самом деле
\emph{\term{интерпретатор} и \term{компилятор} не противоположны}:
интерпретатор может включать в себя компилятор в машинный код как
составную часть. Или наоборот Java считается компилятором, на самом деле
программы преобразуются в \textit{интерпретируемый} \term{байт-код}, который в
свою очередь еще раз компилируется в машинный код\note{JIT\ ---
\textit{необязательная} часть языка Java, см. JavaME на телефонах}.

Еще одна бредовая привычка пользоваться сочетаниями
``интерпретируемый/компилируемый язык'': эта фраза скрывает, чем \emph{язык}
отличвается его его \term{реализации} (я неоднократно и специально использовал
это слово).

\term{Язык программирования}\ --- это \emph{формальный набор
правил}, описывающих \term{синтаксис} (как программы выглядят), \term{семантику}
(что каждая часть значит в соответствии со стандартом языка), требования к
\term{рантайму/виртуальной машине} реализации языка, и \term{стандартную
библиотеку} набор функций и процедур, поставляемых в составе \term{реализации
языка}.

Например, язык Си всегда называют ``компилируемым языком'', но никто не
запрещает написать его интерпретатор. Васик очень часто называли
интерпретатором, но даже на ZX Spectrum был компилятор Lazer Basic. Строго
говоря для некоторых языков (в том числе \metal) нельзя сделать полный
компилятор: некоторые фичи языка могут потребовать перестройки программ в
процессе выполнения. Но даже в таких клинических случаях, как реалиции языка
\lisp, возможно использование техник \term{динамической компиляции} \ref{dyna}
в реальный машинный код. В \ref{llvm}\ мы также рассмотрим встраивание
\term{кросс-компилятора} для микроконтролеров в состав нашего интерпретатора
(техника \term{управляемой компиляции}).

\clearpage
\paragraph{Применение}\ методов программирования, описанных в этой книге:\\
\bigskip

\begin{itemize}[nosep]
\item \emph{обработка текстовых форматов данных}\\
	файлы САПР, исходные данные для расчетных программ
\item командный интерфейс для устройств на микроконтроллерах\\
	управление человеко-читаемыми командами, \emph{передача пакетов данных
	любой структуры и типов}
\item реализация специализированных скриптовых языков
\item обработка исходных текстов программ\\
	модификация, трансляция на другие языки программирования,\\ 
	\emph{универсальный язык независимых от языка шаблонов и метапрограммирования}
	для ЯП с ограниченными или отсутствующими макросами
\end{itemize}

\input{first/eds}
\input{first/whitebox}
\input{first/install}

\secup
