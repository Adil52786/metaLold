\secrel{Базовый Frame}

В качестве модели представления (мета)программ было выбрано расширенное
представление фреймов Мински. Оригинальные фреймы не имели очень важного для
метапрограммирования функционала: \textit{способности хранить упорядоченные
объекты}. Эта фича необходима для представления любых
программ\note{последовательного набора инструкций, или рекурсивно вложенных
структур}, в качестве примера см. деревья разбора/AST и реализацию атрибутных
грамматик \cite{dragon2}. С другой стороны, фреймы имеют практически полное
соответстивие объектной парадигме, в т.ч. объектам \py.

Если мы попытаемся описать дерево программы через граф объектов (фреймов), мы
сталкиваемся с необходимостью иметь \emph{упорядоченные контейнеры}, например
для хранения операндов в выражении деления. Одновременно нам необходим
\emph{ассоциативный массив} для хранения и обработки \term{атрибутов}\ при
преобразованиях кода с использованием \term{атрибутных грамматик}.

\clearpage
\begin{itemize}
  \item 
выделенная иерархия классов применяется для отделения логики фреймов от логики
работы объектной системы в Python\ \note{хотя в принципе динамическая природа
\py\ позволяет реализовать все на встроенных механизмах его объектного движка},
  \item 
явные манипуляции с фреймовыми структурами демонстируют принципы реализации на
низкоуровневых языках с жесткой типизацией, AOT-компиляцией и соответственно
невозможностью произвольно менять структуру класса или единичного объекта в
рантайме (\cpp, \java)
  \item 
добавление некоторых фич, характерных для функциональных и логических языков 
программирования \note{унификация/backtracking и структурный pattern matching}
дает возможности, крайне полезные для метапрограммирования и реализации
интеллектуальных систем (базы знаний, экспертные системы, \term{семантический
ИИ}).
\end{itemize}

\clearpage
\lst{lst/frame.py}{language=Python}
 
Также в большинстве случаев у нас есть необходимость хранить для любого
элемента данных два поля:
\begin{description}

\item[type]\ тэг класса/типа явно указывающий на тип фрейма.\\
Мы принципиально не можем оперировать двумя фреймами в выражении типа
\verb|<string:> + <number:>| без их приведения к одному типу, причем это
приведение часто зависит от контекста, в каком именно смысле мы это выражение
используем (привет долбанутый JavaScript)

\item[value]\ имя фрейма или атомарное значение\note{имена type/value
фиксированы требованиями библиотеки PLY},\\хранимое в типе языка
реализации (\py): нам нужно именовать объекты, хранить значение строк и числовых
данных, поэтому также необходим подкласс фреймов для представления таких
значений-примитивов \ref{prim}.

\item[attr]\verb|{}|\ ассоциативный массив для хранения атрибутов/слотов\\
хранит любые другие фреймы, и использует строки для адресации элементов по имени
атрибута

\item[nest]\verb|[]|\ упорядоченный массив\\
одновременно может работать как список, стек или очередь, адресуется целыми
числами

\end{description}
