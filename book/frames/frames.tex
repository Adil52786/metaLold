\secrel{Концепция фреймов Марвина Мински}\label{frame}\secdown

\clearpage
\cite{minsky} Марвин Минский \textbf{Фреймы для представления знаний}

\begin{itemize}
%   \item 
% \url{https://royallib.com/read/minskiy_marvin/freymi_dlya_predstavleniya_znaniy.html#0}
  \item 
\url{https://ponyatov.quora.com/Minsky-Frames-Database-metaL}\\(см. видео в
начале)
\end{itemize}

В качестве модели представления (мета)программ было выбрано расширенное
представление фреймов Мински. Оригинальные фреймы не имели очень важного для
метапрограммирования функционала: \textit{способности хранить упорядоченные
объекты}. Эта фича необходима для представления любых
программ\note{последовательного набора инструкций, или рекурсивно вложенных
структур}, в качестве примера см. деревья разбора/AST и реализацию атрибутных
грамматик \cite{dragon2}. С другой стороны, фреймы имеют практически полное
соответстивие объектной парадигме, в т.ч. объектам \py.

Если мы попытаемся описать дерево программы через граф объектов (фреймов), мы
сталкиваемся с необходимостью иметь \emph{упорядоченные контейнеры}, например
для хранения операндов в выражении деления. Одновременно нам необходим
\emph{ассоциативный массив} для хранения и обработки \term{атрибутов}\ при
преобразованиях кода с использованием \term{атрибутных грамматик}.

Оригинальная модель фреймов не предусматривает упорядоченное хранение, поэтому
был выбран расширенный вариант модели, для некоторой универсализации,
\begin{itemize}
  \item 
выделенная иерархия классов применяется для отделения логики фреймов от логики
работы объектной системы в Python\ \note{хотя в принципе динамическая природа
\py\ позволяет реализовать все на встроенных механизмах его объектного движка},
  \item 
явные манипуляции с фреймовыми структурами демонстируют принципы реализации на
низкоуровневых языках с жесткой типизацией, AOT-компиляцией и соответственно
невозможностью произвольно менять структуру класса или единичного объекта в
рантайме (\cpp, \java)
  \item 
добавление некоторых фич, характерных для функциональных и логических языков 
программирования \note{унификация/backtracking и структурный pattern matching}
дает возможности, крайне полезные для метапрограммирования и реализации
интеллектуальных систем (базы знаний, экспертные системы, \term{семантический
ИИ}).
\end{itemize}

\lst{lst/frame.py}{language=Python}
 
% , предложенного Марвином Мински,
% добавлением функционала упорядоченного контейнера `nest[]`, позволяющего
% не только хранить `attr{}`ибуты (слоты),
% но и любые элементы данных в явно заданном порядке.
% 

% 
% Также в большинстве случаев у нас есть необходимость хранить для любого
% элемента данных два поля:
% * `type` <br>
% явно указывающий на тип фрейма. Мы принципиально не можем оперировать
% двумя фреймами в выражении типа `<string:> + <number:>` без их приведения к
% одному типу, причем это приведение часто зависит от контекста, в каком именно
% смысле мы это выражение используем (привет долбанутый JavaScript)
% * `value` <br>
% атомарное значение, хранимое в типе языка реализации (Python): нам нужно
% именовать объекты, хранить значение строк и числовых данных, поэтому также
% необходимо подкласс фреймов для представления таких значений-примитивов.
%   
% (*) имена type/value фиксированы требованиями библиотеки PLY, если вы захотите
% использовать ее для создания собтвенного языка метапрограммирования или CLI
% вместо Python

\secup
