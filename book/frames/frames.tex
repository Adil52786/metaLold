\secrel{Концепция фреймов Марвина Мински}\label{frame}\secdown

\clearpage
\cite{minsky} Марвин Минский \textbf{Фреймы для представления знаний}

\begin{itemize}
%   \item 
% \url{https://royallib.com/read/minskiy_marvin/freymi_dlya_predstavleniya_znaniy.html#0}
  \item 
\url{https://ponyatov.quora.com/Minsky-Frames-Database-metaL}\\(см. видео в
начале)
\end{itemize}

\secrel{Базовый Frame}

В качестве модели представления (мета)программ было выбрано расширенное
представление фреймов Мински. Оригинальные фреймы не имели очень важного для
метапрограммирования функционала: \textit{способности хранить упорядоченные
объекты}. Эта фича необходима для представления любых
программ\note{последовательного набора инструкций, или рекурсивно вложенных
структур}, в качестве примера см. деревья разбора/AST и реализацию атрибутных
грамматик \cite{dragon2}. С другой стороны, фреймы имеют практически полное
соответстивие объектной парадигме, в т.ч. объектам \py.

Если мы попытаемся описать дерево программы через граф объектов (фреймов), мы
сталкиваемся с необходимостью иметь \emph{упорядоченные контейнеры}, например
для хранения операндов в выражении деления. Одновременно нам необходим
\emph{ассоциативный массив} для хранения и обработки \term{атрибутов}\ при
преобразованиях кода с использованием \term{атрибутных грамматик}.

\clearpage
\begin{itemize}
  \item 
выделенная иерархия классов применяется для отделения логики фреймов от логики
работы объектной системы в Python\ \note{хотя в принципе динамическая природа
\py\ позволяет реализовать все на встроенных механизмах его объектного движка},
  \item 
явные манипуляции с фреймовыми структурами демонстируют принципы реализации на
низкоуровневых языках с жесткой типизацией, AOT-компиляцией и соответственно
невозможностью произвольно менять структуру класса или единичного объекта в
рантайме (\cpp, \java)
  \item 
добавление некоторых фич, характерных для функциональных и логических языков 
программирования \note{унификация/backtracking и структурный pattern matching}
дает возможности, крайне полезные для метапрограммирования и реализации
интеллектуальных систем (базы знаний, экспертные системы, \term{семантический
ИИ}).
\end{itemize}

\clearpage
\lst{lst/frame.py}{language=Python}
 
Также в большинстве случаев у нас есть необходимость хранить для любого
элемента данных два поля:
\begin{description}

\item[type]\ тэг класса/типа явно указывающий на тип фрейма.\\
Мы принципиально не можем оперировать двумя фреймами в выражении типа
\verb|<string:> + <number:>| без их приведения к одному типу, причем это
приведение часто зависит от контекста, в каком именно смысле мы это выражение
используем (привет долбанутый JavaScript)

\item[value]\ имя фрейма или атомарное значение\note{имена type/value
фиксированы требованиями библиотеки PLY},\\хранимое в типе языка
реализации (\py): нам нужно именовать объекты, хранить значение строк и числовых
данных, поэтому также необходим подкласс фреймов для представления таких
значений-примитивов \ref{prim}.

\item[attr]\verb|{}|\ ассоциативный массив для хранения атрибутов/слотов\\
хранит любые другие фреймы, и использует строки для адресации элементов по имени
атрибута

\item[nest]\verb|[]|\ упорядоченный массив\\
одновременно может работать как список, стек или очередь, адресуется целыми
числами

\end{description}

\secrel{Дамп фрейма}

Для работы с фреймами нам необходимо их человеко-читаемое представление. В
разделе \ref{graphdump}\ описано более естественное отображение в виде графа, но
даже на начальном этапе нам нужен способ видеть их внутреннее состояние.
Наиболее информативным и простым в реализации является представление фрейма в
виде текстового дерева. Каждый фрейм выводится в виде \emph{короткой формы}
\verb|<тип:значение>|, в \emph{полной форме} за ней следует табулированное
дерево, отображающее другие вложенные фреймы.

\smallskip
\lst{lst/dump.py}{language=Python}

\begin{description}
\item[\_\_repr\_\_()] переопределение системного оператора для вывода
\verb|print|
\item[dump()]\ полнотекстовый вывод фрейма в виде текстового дерева
\begin{description}
\item[depth]\ текущая глубина вложенности\\
обход фреймов выполняется рекурсивно, на каждом шаге рекурсии вызывается метод
\verb|dump(depth+1)|, в результате чем глубже вложен фрейм, тем с большим
отступом он будет выведен
\item[prefix]\ ghtabrc при выводе слотов (атрибутов)\\
в начало заголовка фрейма добавляется префикс, содержащий имя слота:
\verb|slotname = <type:value>...|
\end{description}
\end{description}

\smallskip
\lst{lst/dumphead.py}{language=Python}
 \begin{description}
\item[head()]\ дамп в короткой форме\\
выводится только тип и значение фрейма в короткой строке,\\
в некоторых случаях необходимо отличать \textit{копии} фреймов или
\textit{разные} фреймы с одним типом и именем, поэтому через @ выводится
\verb|id()| объекта в шестнадцатеричном виде
\end{description}

\lst{lst/dumpadstr.py}{language=Python}

\begin{description}
\item[str()]\ в простейшем случае кажется естественным напрямую
использовать \verb|Frame.value|, но в некоторых случаях необходимо обеспечить
конкретную форму вывода значения, как пример целые числа или hex; поэтому
введен \emph{переопределяемый метод} для получения value.
\end{description}

\paragraph{Бесконечный рекурсивный цикл при выводе дампа}\ \\

Фреймы могут включать самих себя в качестве значения или вложенного элемента
(непосредственно или в составе других фреймов). Попытка вывода дампа таких
вложений приводит к бесконечной рекурсии и аварийному завершению интерпретатора.

Для борьбы с этим эффектов в класс \verb|Frame| введен статический список
\verb|dumped[]| хранящий указатели на все фреймы, которые уже были выведены.
Это список обнуляется при первом выводе корневого фрейма (\verb|depth=0|), а
затем каждый раз проверяется, есть ли уже текущий объект в этом списке: если
есть\ --- возвращается только короткая форма с \ldots, иначе фрейм добавляется.

\clearpage
\lst{lst/dumped.py}{language=Python}

\secup
